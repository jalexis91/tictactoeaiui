<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!-- InstanceBegin template="/Templates/template1.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script type="text/javascript" src="http://code.jquery.com/jquery-1.9.1.js"></script>
<script type="text/javascript" src="jquery.touchSwipe.min.js"></script>

<!-- InstanceBeginEditable name="doctitle" -->
<title>Game</title>
<!-- InstanceEndEditable -->



<style type="text/css">
@import url("style.css");
body {
	background-color: #F3F4EC;
}
</style>

<script type="text/javascript">//<![CDATA[ 
    $(window).load(function(){
      $("[data-toggle]").click(function() {
        var toggle_el = $(this).data("toggle");
        $(toggle_el).toggleClass("open-sidebar");
      });
    });//]]>  
    
</script>

</head>

<body>
<div class="container">
      <div id="sidebar">
          <ul>
              <li><a href="index.html">Home</a></li>
              <li><a href="newgame.html">New Game</a></li>
              <li><a href="settings.html">Settings</a></li>
          </ul>
      </div>
  <div class="main-content">
          <a href="#" data-toggle=".container" id="sidebar-toggle">
              <span class="bar"></span>
              <span class="bar"></span>
              <span class="bar"></span>
          </a>
          <div class="content">
<!-- InstanceBeginEditable name="head" -->
<h1>GAME</h1>
<div id="board">
              
<script>

var image1=new Image(); 
image1.src="images/triangle.png";
var image2=new Image(); 
image2.src="images/circle.png";

var level=1, myway, mynextmove;
var game_board;
var best_move;
var active_player;
var potentialmoves;
var count,depth,alpha,subalpha;
var INFINITY = 999999999;
var tmp, nummovesmade, iswon, iswonbyhuman, iswonbyai, content, winner;
var tmp_move;
var pcwins=[0,0,0,0];
var playerwins=[0,0,0,0];
var draws=[0,0,0,0]; 
var playerstarts=true;
var moves=new Array();  // tells which spaces are open and which are taken
						// if moves[] == 0, space is empty
						// if moves[] == 1, space is taken by human player
						// if moves[] == 2, space is taken by AI player
var game=new Array(9); //works with nummovesmade to track the moves that have been made; doesn't keep track of who made the moves though
var choices=[11,12,13,21,22,23,31,32,33]; // possible moves that can be made
var corners=[11,13,31,33]; // corners of the board

// possible winning states
var ways=new Array();
ways[1]=[0,11,12,13];
ways[2]=[0,21,22,23];
ways[3]=[0,31,32,33];
ways[4]=[0,11,21,31];
ways[5]=[0,12,22,32];
ways[6]=[0,13,23,33];
ways[7]=[0,11,22,33];
ways[8]=[0,13,22,31]; 

function init(){
	oktoplay=true;
	iswon=false;
	nummovesmade=0; //total number of moves made; increments by 1
	writetext(4);

	moves[11]=0; 
	moves[12]=0; 
	moves[13]=0; 
	moves[21]=0; 
	moves[22]=0; 
	moves[23]=0; 
	moves[31]=0; 
	moves[32]=0; 
	moves[33]=0;
	for(i=0;i<=8;i++){
		document.images['rc'+choices[i]].src="images/blank.png";
		document.images['rc'+choices[i]].alt="";
		game[i]=0;
	}
	if(!playerstarts){
		aiturn();
	}
}

function writetext(num, mynextmove){
	switch(num){
	case 1: content='Draw';
	break;
	case 2: content='You Lose!';
	break;
	case 3: content='You Win!';
	break;
	case 4: content='LEVEL: '+level+'\n\nComputer Wins:  This level- '+pcwins[level]+'  (Total: '+(pcwins[0]+pcwins[1]+pcwins[2]+pcwins[3])+')\nPlayer Wins  :  This level- '+playerwins[level]+'  (Total: '+(playerwins[0]+playerwins[1]+playerwins[2]+playerwins[3])+')\nDraws        :  This level- '+draws[level]+'  (Total: '+(draws[0]+draws[1]+draws[2]+draws[3])+')';
	break;
	}
	document.getElementById('p1score').innerHTML = 'AI: '+(pcwins[0]+pcwins[1]+pcwins[2]+pcwins[3]);
	document.getElementById('draws').innerHTML = 'D: '+(draws[0]+draws[1]+draws[2]+draws[3]);
	document.getElementById('p2score').innerHTML = 'P1: '+(playerwins[0]+playerwins[1]+playerwins[2]+playerwins[3]);
	
	if(num<4)setTimeout('init(4)',1000);
}

function setlevel(x){ // set game level and start/restart the game
	if (level!=x){
		level=x;
		init();
	}
}

// updates cell for human player move
function setbutton(cellnum){
	if (!iswon){ 			
		if(moves[cellnum]==0){ // check if move has been made at that cell
			document.images['rc'+cellnum].src="images/triangle.png";
			document.images['rc'+cellnum].alt=" X ";
			moves[cellnum]=1; // note that move has been made at the spot by human player
			game[nummovesmade]=cellnum; // note that the nummovesmade-th move was at this cell
			nummovesmade++; // increment nummovesmade
			if(level==0 || level==2){
				findwinner(true); // see if someone has won
			}
			else if(level==1){
				findwinnerlevel2();
			}
			else{
				findwinner(true);
			}
		}
		else alert('You cannot move here!'); // if move has already been made at that cell, alert the player
	}
}

function checkwinstates(ofai) {
    if (level >= 1) { // if hard or medium level
        str = (ofai) ? 2 : 1;
		// goes through checking if there are two moves played out of three in a possible winning state for a certain player
		// if ofai == true, it checks for winning states of the AI player; meaning if the pc strategy is to win then the AI will play the last
		// available move in the winning state in order to complete the winning state
		// if ofai == false, it checks for winning states of the human player
		// either blocks winning moves of human player (step 2 of newell and simon) or makes the winning move for AI (step 1 of newell and simon)
        for (n = 1; n <= 8; n++) {
            if ((moves[ways[n][1]] == str) && (moves[ways[n][2]] == str) && (moves[ways[n][3]] == 0)) { // if 2 out of 3 winning state moves are made
                tmp = ways[n][3];
            }
            if ((moves[ways[n][1]] == str) && (moves[ways[n][3]] == str) && (moves[ways[n][2]] == 0)) {
                tmp = ways[n][2];
            }
            if ((moves[ways[n][2]] == str) && (moves[ways[n][3]] == str) && (moves[ways[n][1]] == 0)) {
                tmp = ways[n][1];
            }
        }
    }
}

function selectcorner(which){ // select empty corner
	if (which=="empty"){
		do{
			tmp=corners[Math.floor(Math.random()*4)]; // Math.floor rounds down to nearest whole number	
													  // Math.random gives a random number between 0 and 1 that isn't a whole number
													  // multiply Math.random() by 4 to get a number between 0 and 4 and add Math.floor to make it an integer
													  // i.e. tmp = a random corner from the array corners=[11,13,31,33] selected from between pos 0 and 3 in array
		}
		while(moves[tmp]!=0); // do until it finds an empty corner
	}
	else
	tmp=corners[Math.floor(Math.random()*4)];
}


function newellsimonstrategy(){ // takes care of steps 3-8 of simon and newell
	if (!playerstarts){ // i.e. if the AI player starts
		if (nummovesmade==0){  // if no moves made, choose center space; step 5 of newell and simon strategy (center)
			tmp=22;
		}
		else if (nummovesmade==2){
			// uses step 3 of newell and simon strategy (fork)
			// set up a fork - 1
			if (game[1]==11 || game[1]==13 || game[1]==31 || game[1]==33){ // if player moved in corner
				// step 6 of newell and simon strategy (opposite corner)
				tmp=44-game[1];	// play opposite corner
			}
			// set up a fork - 2
			else{ // if AI played center cell for 1st move and human did NOT play a corner
				// step 7 of newell and simon strategy (empty corner)
				dlta=22-game[1]; 
				op0=22+dlta+(10/dlta);
				op1=22+dlta-(10/dlta);
				tmp=eval("op"+Math.floor(Math.random()*2)); // let tmp be op0 or op1 (doesn't matter which)
			}
		}
		else if (nummovesmade==4){ // and no winning state moves found
			// newell and simon step 3 (finish fork)
			// finish fork setup 1; shouldn't happen w/ 2 because checkwinstates should catch it
				tmp=44+game[2]-(2*game[3]);
		}
		else if (nummovesmade==6){ // and no winning state moves found
			// newell and simon step 7 (empty corner)
			if(moves[11]==0 || moves[13]==0 ||  moves[31]==0 || moves[33]==0){
				selectcorner("empty");
			}
			else{ // newell and simon step 8 (empty space)
				do{
					tmp=choices[Math.floor(Math.random()*9)];
					document.scores.scores4.value=tmp;
					document.getElementById('lastaimove').innerHTML = 'Last AI move made at: '+tmp;
				}
				while(moves[tmp]!=0);
			}
		}
		else if (nummovesmade==8){ // and no winning state moves found
			// newell and simon step 7 (empty corner)
			if(moves[11]==0 || moves[13]==0 ||  moves[31]==0 || moves[33]==0){
				selectcorner("empty");
			} 
			else{ // newell and simon step 8 (empty space)
				do{
					tmp=choices[Math.floor(Math.random()*9)];
					document.scores.scores4.value=tmp;
					document.getElementById('lastaimove').innerHTML = 'Last AI move made at: '+tmp;
				}
				while(moves[tmp]!=0);
			}
		}
	}
	else if (level==2){ // human player starts the game
		if (nummovesmade==1){  // step 5 of newell and simon strategy (center)
			if (game[0]==11 || game[0]==13 || game[0]==31 || game[0]==33){
				tmp=22;
				myway=1;
			}
			else if (game[0]==22){ // step 7 of newell and simon strategy (empty corner)
				selectcorner("any");
				myway=2;
			}
			else{ // step 5 of newell and simon strategy (center)
				tmp=22;
				myway=3;
			}
		}
		else if (nummovesmade==3){
			if (myway==1){ // ai at center and at least 1 corner move
				if (game[2]==44-game[0]){ // if third move is an opposite corner move
					//tmp=choices[1+(2*Math.floor(Math.random()*4))];
					if(moves[11]==0 || moves[13]==0 ||  moves[31]==0 || moves[33]==0){
						selectcorner("empty"); // step 6 of newell and simon strategy (block fork)
					} 
					// this else should never occur
					else{ // newell and simon step 8 (empty space)
						do{
							tmp=choices[Math.floor(Math.random()*9)];
							document.scores.scores4.value=tmp;
							document.getElementById('lastaimove').innerHTML = 'Last AI move made at: '+tmp;
						}
						while(moves[tmp]!=0);
					}
				}
				else { // if third move is not a corner move 
					tmp=44-game[0]; // step 6 of newell and simon strategy (opposite corner)
				}
			}
			else if (myway==2){ // human in center and ai at corner
				if (game[2]==44-game[1]){ // if human played opposite corner then pick other corner
					selectcorner("empty"); // step 7 of newell and simon strategy (empty corner)
				}
			}
			else if (myway==3){ // ai at center and 1st human move not in a corner
				if (game[2]==11 || game[2]==13 || game[2]==31 || game[2]==33){ // if human made a corner move
					tmp=44-game[2]; // step 6 of newell and simon strategy (opposite corner)
				}
				else if (game[2]==44-game[0]){ // if human played opposite from self
					if(moves[11]==0 || moves[13]==0 ||  moves[31]==0 || moves[33]==0){
						selectcorner("empty"); // step 4 of newell and simon strategy (block fork)
					} 
					// this else should never occur
					else{ // newell and simon step 8 (empty side)
						myway=31;
						dlta=22-game[2];
						tmp=22+(10/dlta);
						mynextmove=tmp+dlta;
					}
				}
				else{ // if ai at center and human moves not in a corner?
					if(moves[11]==0 || moves[13]==0 ||  moves[31]==0 || moves[33]==0){
						selectcorner("empty"); // step 7 of newell and simon strategy (empty corner)
					} 
					else{ // newell and simon step 8 (empty side)
						//helps pick the best empty side
						dlta=22-game[0];
						op0=game[0]+(10/dlta);	
						op1=game[0]-(10/dlta);	
						op2=game[2]+dlta;	
						tmp=eval("op"+Math.floor(Math.random()*3));
					}
				}
			}
		}
		else if (nummovesmade==5){
			if(myway==31){
				tmp=mynextmove;
			}
			else{
				if(moves[11]==0 || moves[13]==0 ||  moves[31]==0 || moves[33]==0){
					selectcorner("empty"); // step 6 of newell and simon strategy (block fork)
				} 
				else{ // newell and simon step 8 (empty space)
					do{
						tmp=choices[Math.floor(Math.random()*9)];
						document.scores.scores4.value=tmp;
						document.getElementById('lastaimove').innerHTML = 'Last AI move made at: '+tmp;
					}
					while(moves[tmp]!=0);
				}
			}
		}
		else if (nummovesmade==7){
			if(moves[11]==0 || moves[13]==0 ||  moves[31]==0 || moves[33]==0){
				selectcorner("empty"); // step 6 of newell and simon strategy (block fork)
			} 
			else{ // newell and simon step 8 (empty space)
				do{
					tmp=choices[Math.floor(Math.random()*9)];
					document.scores.scores4.value=tmp;
					document.getElementById('lastaimove').innerHTML = 'Last AI move made at: '+tmp;
				}
				while(moves[tmp]!=0);
			}
		}
	}
}

function findwinnerlevel2(){
	iswonbyhuman=false;
	iswonbyai=false;
	for(n=1;n<=8;n++){
		if( (moves[ways[n][1]]==1) && (moves[ways[n][2]]==1) && (moves[ways[n][3]]==1) ){ // if moves of a possible winning state have been made by the same player then the player wins
			iswonbyhuman=true; // game has been won
			break;
		}
	}
	for(n=1;n<=8;n++){
		if( (moves[ways[n][1]]==2) && (moves[ways[n][2]]==2) && (moves[ways[n][3]]==2) ){ // if moves of a possible winning state have been made by the same player then the player wins
			iswonbyai=true; // game has been won
			break;
		}
	}
	if(iswonbyhuman==true){ // if someone has won
			playerwins[level]++;
			playerstarts=true;	// human starts next game
			writetext(3);
	}
	else if(iswonbyai==true){		 // if isplayer is false, add to AI wins
		pcwins[level]++;
			playerstarts=false; // AI starts next game
			writetext(2);
	}
	else{ // if no one has won
		if(nummovesmade>8){ // if all move have been made --> draw
			draws[level]++;
			playerstarts=!playerstarts;
			writetext(1);
		}
		else{
			//winner='none';
			aiturn();
		}
	}
}

function findwinnerminmax(board){
	iswonbyhuman=false;
	iswonbyai=false;
	var moveswin = new Array();
	moveswin[11]=board[0];
	moveswin[12]=board[1];
	moveswin[13]=board[2];
	moveswin[21]=board[3];
	moveswin[22]=board[4];
	moveswin[23]=board[5];
	moveswin[31]=board[6];
	moveswin[32]=board[7];
	moveswin[33]=board[8];
	for(n=1;n<=8;n++){
		if( (moveswin[ways[n][1]]==1) && (moveswin[ways[n][2]]==1) && (moveswin[ways[n][3]]==1) ){ // if moves of a possible winning state have been made by the same player then the player wins
			iswonbyhuman=true; // game has been won
			break;
		}
	}
	for(n=1;n<=8;n++){
		if( (moveswin[ways[n][1]]==2) && (moveswin[ways[n][2]]==2) && (moveswin[ways[n][3]]==2) ){ // if moves of a possible winning state have been made by the same player then the player wins
			iswonbyai=true; // game has been won
			break;
		}
	}
	if(iswonbyhuman==true){ // if someone has won
		winner = 'human';
	}
	else if(iswonbyai==true){		 // if isplayer is false, add to AI wins
		winner = 'ai';
		best_move = tmp_move;
	}
	else{ // if no one has won
		if(nummovesmade>8){ // if all move have been made --> draw
			winner = 'draw';
		}
		else{
			winner='none';
		}
	}
	return winner;
}

function findwinner(isplayer){
	me=(isplayer)? 1 : 2; // if isplayer==true then me=1 (i.e. human player), if isplayer==false then me=2 (i.e. AI player)
	for(n=1;n<=8;n++){
		if( (moves[ways[n][1]]==me) && (moves[ways[n][2]]==me) && (moves[ways[n][3]]==me) ){ // if moves of a possible winning state have been made by the same player then the player wins
			iswon=true; // game has been won
			break;
		}
	}
	if(iswon){ // if someone has won
		if(isplayer){ // if isplayer is true, add to human wins
			playerwins[level]++;
			playerstarts=true;	// human starts next game
			writetext(3);
		}
		else{		 // if isplayer is false, add to AI wins
			pcwins[level]++;
			playerstarts=false; // AI starts next game
			writetext(2);
		}
	}
	else{ // if no one has won
		if(nummovesmade>8){ // if all move have been made --> draw
			draws[level]++;
			playerstarts=!playerstarts;
			writetext(1);
		}
		else if(isplayer){ // if human player, then it is the pc players turn
			aiturn();
		}
	}
}

function randommove(){ // make a random move; used for easy mode
	do{
		tmp=choices[Math.floor(Math.random()*9)];
		document.scores.scores4.value=tmp;
		document.getElementById('lastaimove').innerHTML = 'Last AI move made at: '+tmp;
	}
	while(moves[tmp]!=0);
	
}

function newboard(board,player,depth){

}

function nextmove(board,player){
	
}

function minimax(board,currentplayer){ // make a random move; used for easy mode
	minimax_recurse(board,currentplayer,0);
	tmp = best_move;
}

function minimax_recurse(board,player,depth){
	potentialmoves=new Array();
	//var count;
	//if maxed out, return the node heuristic value
    if(depth > 8){
        return 0;
	}
	
    //see if there's a winner
    winner = findwinnerminmax(board);
    if (winner == 'ai'){
        return 999999999;            //ai wins!
	}
    else if (winner == 'human'){
        return -999999999;           //ai loses
	}
    else if (winner == 'draw'){
        return 0;                   //tie game!
	}

	if(player == 'ai'){
		other_player = 'human';
	}
	else{
		other_player = 'ai';
	}

    //init alpha with this starting node's value.  The current player
    //will raise this value; the other player will lower it.
    if(player == active_player){
        alpha = -999999999;
	}
    else{
        alpha = +999999999;
	}

    //get a list of potential moves this turn:
    //board = [moves[11],moves[12],moves[13],moves[21],moves[22],moves[23],moves[31],moves[32],moves[33]];

    //for all those moves, make a speculative copy of this board
	count=0;
    for (t=0;t<9;t++){
		if (board[t] == 0){
			if(t==0){
				potentialmoves[count] = 11;
				count++;
			}
			else if(t==1){
				potentialmoves[count] = 12;
				count++;
			}
			else if(t==2){
				potentialmoves[count] = 13;
				count++;
			}
			else if(t==3){
				potentialmoves[count] = 21;
				count++;
			}
			else if(t==4){
				potentialmoves[count] = 22;
				count++;
			}
			else if(t==5){
				potentialmoves[count] = 23;
				count++;
			}
			else if(t==6){
				potentialmoves[count] = 31;
				count++;
			}
			else if(t==7){
				potentialmoves[count] = 32;
				count++;
			}
			else if(t==7){
				potentialmoves[count] = 33;
				count++;
			}
		}
	}
		var moves2 = new Array();
		var board2 = new Array();
		moves2[11]=moves[11];
		moves2[12]=moves[12];
		moves2[13]=moves[13];
		moves2[21]=moves[21];
		moves2[22]=moves[22];
		moves2[23]=moves[23];
		moves2[31]=moves[31];
		moves2[32]=moves[32];
		moves2[33]=moves[33];
		
		for(l=0;l<count;l++){
			moves2[potentialmoves[l]]=2;
			board2=[moves2[11],moves2[12],moves2[13],moves2[21],moves2[22],moves2[23],moves2[31],moves2[32],moves2[33]];
			//and recurse down to find the alpha value of the subtree!
			tmp_move = potentialmoves[l];
			subalpha = minimax_recurse(board2, other_player, depth + 1);
			
			//If we're the current player, we want the maximum valued
			//node from all the child nodes. If we're the opponent
			//we want the minimum:
			if (player == active_player){
				//if we're at the root, remember the best move
				if(depth == 0 && alpha <= subalpha){
					best_move = potentialmoves[l];
					//moves2[best_move]=2;
				}

				alpha = Math.max(alpha, subalpha);  //push alpha up (maximize)
			}
			else{
				alpha = Math.min(alpha, subalpha);  //push alpha down (minimize)
			}
		}
    //finally, return this subtree's value to its parent:
    return alpha;
}

function aiturn(){
	active_player=='ai';
	tmp='00'; // reset tmp each pc turn
	if(level==2){ // hard mode; newell and simon strategy
		//checkwinstates() takes care of steps 1 and 2 of newell and simon strategy for winning or blocking
		checkwinstates(true); // checks for AI win states; if none are found it returns tmp=='00' and checks for human win states
		if(tmp=='00'){ 
			checkwinstates(false); // check for human player winning states
			// tmp==00 still returned if 2 out of 3 winning state moves aren't found
		}
		// if no win states found yet continue with strategy
		if(tmp=='00'){
			newellsimonstrategy();
		}
	}
	if(level==1){ // medium mode; minimax strategy
		if(tmp=='00'){
			//game_board=new Array();
			game_board = [moves[11],moves[12],moves[13],moves[21],moves[22],moves[23],moves[31],moves[32],moves[33]];
			//tmp = minimax(game_board,'ai');
			minimax(game_board,'ai');
			//tmp = best_move;
		}
	}
	if(level==0){ // easy mode
		randommove();
	}
	moves[tmp]=2; // populate the move space with an AI move
	game[nummovesmade]=tmp;
	document.images['rc'+tmp].src="images/circle.png";
	document.images['rc'+tmp].alt=" O ";
	document.scores.scores4.value=tmp;
	document.getElementById('lastaimove').innerHTML = tmp;
	document.getElementById('lastaimove').innerHTML = 'Last AI move made at: '+tmp;
	
	nummovesmade++;
	findwinner(false);
	active_player=='human';
}
	
window.onload=init;
</script>

<div id="board">
    <table cellpadding="0" cellspacing="0">
        <tbody>
            <tr id="row1">
                <td class="square"><a href="javascript:setbutton(11)"><img src="images/blank.png" border="0" name="rc11" alt=""></img></a>
                </td>
                <td class="square v"><a href="javascript:setbutton(12)"><img src="images/blank.png" border="0" name="rc12" alt=""></img></a>
                </td>
                <td class="square"><a href="javascript:setbutton(13)"><img src="images/blank.png" border="0" name="rc13" alt=""></img></a>
                </td>
                <td class="square"></td>
                <td class="square p1score" id="p1score"></td>
            </tr>
            <tr id="row2">
                <td class="square h"><a href="javascript:setbutton(21)"><img src="images/blank.png" border="0" name="rc21" alt=""></img></a>
                </td>
                <td class="square h v"><a href="javascript:setbutton(22)"><img src="images/blank.png" name="rc22" alt=""></img></a>
                </td>
                <td class="square h"><a href="javascript:setbutton(23)"><img src="images/blank.png" border="0" name="rc23" alt=""></img></a>
                </td>
                <td class="square"></td>
                <td class="square draws" id="draws"></td>
            </tr>
            <tr id="row3">
                <td class="square"><a href="javascript:setbutton(31)"><img src="images/blank.png" border="0" name="rc31" alt=" O "></img></a>
                </td>
                <td class="square v"><a href="javascript:setbutton(32)"><img src="images/blank.png" border="0" name="rc32" alt=""></img></a>
                </td>
                <td class="square"><a href="javascript:setbutton(33)"><img src="images/blank.png" border="0" name="rc33" alt=""></img></a>
                </td>
                <td class="square"></td>
                <td class="square p2score" id="p2score"></td>
            </tr>
        </tbody>
    </table>
    <br />
    <br />
    <table cellpadding="4" cellspacing="3">
        <tbody>
            <form name="scores">
                <tr>
                    <td>
                        <input type="radio" name="level" id="level" onclick="setlevel(0)" checked="">Level 1 -- Easy</input>
                    </td>
                    <td>
                        <input type="radio" name="level" id="level" onclick="setlevel(1)">Level 2 -- Medium</input>
                    </td>
                    <td>
                        <input type="radio" name="level" id="level" onclick="setlevel(2)">Level 3 -- Hard</input>
                    </td>
                </tr>
                <tr>
                    <td align="left" colspan="3">
                        <!-- <textarea name="scores2" cols="45" rows="5"></textarea>
<br> !-->
                        <textarea name="scores4" cols="45" rows="1"></textarea>
                    </td>
                </tr>
            </form>
            <tr>
                <td class="lastaimove" id="lastaimove" colspan="3"></td>
            </tr>
        </tbody>
    </table>
</div>
<!--<table cellpadding="4" cellspacing="3">
    <tbody>
        <tr>
            <td>
                <div id="pcstratistowin">pcstratistowin:</div>
            </td>
        </tr>
        <tr>
            <td>
                <div id="pcstratstr">pcstratstr:</div>
            </td>
        </tr>
        <tr>
            <td>
                <div id="pcstratif1">pcstratif1:</div>
            </td>
        </tr>
        <tr>
            <td>
                <div id="pcstratif2">pcstratif2:</div>
            </td>
        </tr>
        <tr>
            <td>
                <div id="pcstratif3">pcstratif3:</div>
            </td>
        </tr>
        <tr>
            <td>
                <div id="pcstratcheck">pcstratcheck:</div>
            </td>
        </tr>
        <tr>
            <td>
                <div id="pcstratn">pcstratn:</div>
            </td>
        </tr>
        <tr>
            <td>
                <div id="lastaimove">lastaimove:</div>
            </td>
        </tr>
        </td></tr>
    </tbody>
</table>!-->
</div>
<!-- InstanceEndEditable -->
    </div>
  </div>
  </div>

</body>
<!-- InstanceEnd --></html>
